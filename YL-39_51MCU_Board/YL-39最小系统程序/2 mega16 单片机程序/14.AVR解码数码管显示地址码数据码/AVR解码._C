/******************************************************************************/
/*  Name:  数码管显示地址码与键码J2要插上                                     */
/*  编译坏境：ICCAVR 7.16                                                     */
/*  Designed by :廖文丹                         Date:2007/6/21                */
/*  开发环境:ICCAVR                                                           */
/*  QQ:80184985 真红炎神                                                      */
/******************************************************************************/  
  #include <iom16v.h>
  #include <macros.h>  
  #define uint  unsigned int
  #define uchar unsigned char
  #define Set_Bit(val, bitn)    (val |=(1<<(bitn))) 
  #define Clr_Bit(val, bitn)    (val&=~(1<<(bitn))) 
  #define Get_Bit(val, bitn)    (val &(1<<(bitn)) ) 
  #define Cpl_Bit(val, bitn)    (val^=(1<<(bitn)) )
  #define fosc 8000000 //晶振8MHZ
  #define baud 19200	 //波特率
//*****************************************************************************/
   uchar  disbuf[4]={1,2,3,4};
   uchar  discode[]={ 0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x80,0xc6,0xc0,0x86,0x8e };  //段码表
   uchar  disbit[4]  ={ 0xFE, 0xFD,0xFB,0xF7}; //选通值   
   uchar bitcnt;
   uint newFall;
   uint oldFall;
   uint data0;
   uint data1;  
  //函数声明
   void ICEInit(void);
 
/******************************************************************************/
//延时函数
/******************************************************************************/  	                                             							
      void delay(void)   
           {
		     uchar i;
             for(i=0;i<255;i++);
           }
/******************************************************************************/
//显示函数
/******************************************************************************/  
	  void Display(void)
         {  
		    uchar i;
            for(i=0;i<4;i++)
                {
		         PORTB=discode[disbuf[i]];
                 PORTA=disbit[i];
                 delay();
                 PORTA=0xff;
			    } 
		 }
/******************************************************************************/
//T/C1 捕获初始代
/******************************************************************************/               
 void ICEInit(void) //T/C1初始化
 {
    TIMSK=0X20;   //使能捕获中断
    TCCR1A=0X00;  //T/C1时钟与系统相同，本文使用系统AVR内部自带8MHz振荡源.T/C1时钟周期为1μs
    TCCR1B=0X82;  //使能噪音抑制，下降沿触发中断
 }
/******************************************************************************/
//主函数 显示用
/******************************************************************************/  
 void main(void)
 {  
     DDRA=0xFF;       //设为输出口     
     DDRB=0xFF;       //设为输出口 
     PORTA=0xFF;      
     PORTB=0xFF; 
     ICEInit();
     SEI();
	 
   while(1)
   {
      Display();
   }
  } 
  
/******************************************************************************/
//捕获中断用作解码
/******************************************************************************/  
#pragma interrupt_handler CAPT_ISR:iv_TIMER1_CAPT 

void CAPT_ISR(void)
{
  uchar a;
  uint temp;
  newFall=ICR1;
  temp=newFall-oldFall; //计算脉冲加间隔的时间
  oldFall=newFall;
   
 if(temp>1024 && temp<1225) // "0"信号
   {
    temp=0;
   }

else if(temp>2145 && temp<2345) //“1”信号
   {
    temp=1;
   }

else if(temp>13400 && temp<13600) //header信号

  {
   bitcnt=0;
   data0=0;
   data1=0;
   return; //返回，等待下次开始接收
  }

else ///干扰信号
  {
    return;
  }
  bitcnt++;
    if(bitcnt<16) //开始接收前16位
  {
    data0=data0|(uint)temp;
    data0=data0<<1;
   }
else if(bitcnt==16)
  {
   data0=data0|(uint)temp;
  }
 else if(bitcnt<32) //开始接收后16位
 { 
   data1=data1|(uint)temp;
   data1=data1<<1;
 }
 else if(bitcnt==32) //接收完最后一位
 {
    data1=data1|(uint)temp;
	disbuf[0]=(data0>>8)/16;//更新显示
	disbuf[1]=(data0>>8)%16;
	disbuf[2]=(data1>>8)/16;
	disbuf[3]=(data1>>8)%16;
 }
 
}
